#%%import pandas as pdimport jsonfrom sqlalchemy import create_engineimport osimport numpy as npfrom datetime import datetimeimport sysimport matplotlib.pyplot as pltimport seaborn as snssns.set_theme()sys.path.append('/Users/rowanlavelle/Documents/Projects/')from nba.src.db_manager import DBManagerfrom sklearn.linear_model import LinearRegression#%%db_path = '/Users/rowanlavelle/nba/nba.db'engine = create_engine(f'sqlite:///{db_path}')#%%dbm = DBManager(engine)#%%x = dbm.get_players()#%%df = dbm.get_team_games_season('Celtics', '00', '2021-22')df = dbm.get_player_stats_season('kevin-durant', '00')assert df.shape[0] > 0df['ppm'] = df.points / df.minutes#%%t = np.arange(df.shape[0])#%%X = np.zeros((t.shape[0],3))X[:,0] = tX[:,1] = t**0.5X[:,2] = t**2y = df.ppm.values.reshape(-1,1)#%%m = LinearRegression().fit(X,y)p = m.predict(X).flatten()#%%plt.clf()for season,group in df.groupby(df.season):    t = np.arange(group.shape[0])    plt.plot(t, (group.points - group.points.mean()).cumsum())plt.show()#%%x = df[df.season == '2022-23']t = np.arange(x.shape[0])y = (x.points - x.points.mean()).cumsum().values#%%from scipy.ndimage import gaussian_filter1d# Apply Gaussian smoothingsigma = 1  # Standard deviation of the Gaussian kernely_smooth = gaussian_filter1d(y, sigma)#%%def slope(x, y, i):        # Calculate slope using finite differences (central difference)    dx = x[i+1] - x[i-1]    dy = y[i+1] - y[i-1]    slope = dy / dx        return slope#%%s = [slope(t,y_smooth,i) for i in t[1:-1]]#%%plt.clf()plt.plot(t, x.points, alpha=0.5)plt.hlines([x.points.mean()], t[0], t[-1], ls='--')plt.plot(t, y)plt.plot(t, y_smooth, marker='.')plt.plot(t[1:-1], s, marker='.', alpha=0.2)plt.show()#%%x.points.mean(), x.points.std()#%%z = np.random.normal(x.points.mean(), x.points.std(), size=47)plt.clf()plt.hist(x.points)plt.hist(z, alpha=0.5)plt.show()#%%g = np.random.normal(df.points.mean(), df.points.std(), size=5000)z = np.random.normal(x.points.mean(), x.points.std(), size=5000)plt.clf()plt.hist(g,bins=100)plt.hist(z,bins=100,alpha=0.5)plt.show()#%%plt.clf()plt.hist(df.points, bins=50)plt.hist(x.points)plt.show()#%%plt.clf()plt.hist(x.points, bins=20)plt.show()#%%np.std(df.ppm / p) / np.mean(df.ppm / p) #%%np.mean(df.points), np.std(df.points), np.std(df.points) / np.mean(df.points)#%%np.mean(df.ppm), np.std(df.ppm) / np.mean(df.ppm)#%%mu_ppm = np.mean(y.ppm)#%%y['points_estimate'] = mu_ppm * y.minutes#%%y['err'] = y.points - y.points_estimate#%%np.sum(y.err ** 2)#%%x = y.groupby(['season']).err.apply(lambda e: np.sum(e**2)).reset_index(drop=False)#%%plt.clf()for k,g in y.groupby(['season']):    g['rolling_ppm'] = g.ppm.rolling(window=10).mean()    plt.plot(np.arange(len(g)), g.rolling_ppm, label=g.season.values[0])plt.legend()plt.show()#%%y['rolling_ppm'] = y.ppm.rolling(window=10).mean()#%%plt.clf()plt.plot(y.date, y.rolling_ppm)plt.show()#%%len(y), y.date.nunique()#%%players = dbm.get_players()#%%stats = dbm.get_season_stats('00')#%%def f(group):    group['ppm'] = group.points/group.minutes    np.mean(y.points), np.std(y.points), np.std(y.points) / np.mean(y.points)    np.mean(y.ppm), np.std(y.ppm) / np.mean(y.ppm)    return pd.DataFrame({            'ppm':[np.mean(group.ppm)],            'ppm_std':[np.std(group.ppm)],            'ppm_std_pct':[np.std(group.ppm)/np.mean(group.ppm)],            'points':[np.mean(group.points)],            'points_std':[np.std(group.points)],            'points_std_pct':[np.std(group.points)/np.mean(group.points)],            'ngames':len(group),            'minutes':np.mean(group.minutes)        })x = stats.groupby(['player_id']).apply(f).reset_index(drop=False)#%%x = pd.merge(x,players,on='player_id')